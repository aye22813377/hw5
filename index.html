<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hello</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <h2>Computer programming</h2>
    <hr>
    <i>From Wikipedia, the free encyclopedia</i><br>
    <br>
    <b>Computer programming</b> is the process of designing and building an executable computer program for accomplishing a specific computing task. <b>Programming</b><br>
    involves tasks such as: analysis, generating algorithms, profiling algorithms' accuracy and resource consumption, and the implementation of algorithms in a chosen<br>
    programming language (commonly referred to as coding). The source code of a program is written in one or more languages. The purpose of programming is to find<br>
    a sequence of instructions that will automate the performance of a task on a computer, often for solving a given problem. The process of programming thus often<br>
    requires expertise in several different subjects, including knowledge of the application domain, specialized algorithms, and formal logic.<br>
    <br>
   <div> <h4 class="cntr">Contents</h4>
    <ol>
   <li><a href="#hist"> History</a></li>
<li><a href="#mod">Modern programming</a></li>
<ol>  
<li><a href="#qa">Quality requirements</a></li>
<li><a href="#Read"> Readability of source code</a></li>
<li><a href="#Algo"> Algorithmic complexity</a></li>
<ol>  
<li><a href="#Chess">Chess algorithms as an example</a></li>
</ol>  
</ol>  
<li><a href="#Lang"> Programming languages</a></li>
<li><a href="#Progers">Programmers</a></li>
</ol>
</div>    
<h3 id="hist">History</h3>
<hr><br>
    Programmable devices have existed at least as far back as 1206 AD, when the automata of Al-Jazari were programmable, via pegs and cams, to play various rhythms<br>
    and drum patterns; and the 1801 Jacquard loom could produce entirely different weaves by changing the "program" - a series of pasteboard cards with holes<br>
    punched in them.<br>
    <br>
    However, the first computer program is generally dated to 1843, when mathematician Ada Lovelace published an algorithm to calculate a sequence of Bernoulli<br>
    numbers, intended to be carried out by Charles Babbage's Analytical Engine. Women would continue to dominate the field of computer programming until the mid<br>
    1960s.<br>
    <br>
    In the 1880s Herman Hollerith invented the concept of storing data in machine-readable form. Later a control panel (plugboard) added to his 1906 Type I Tabulator<br>
    allowed it to be programmed for different jobs, and by the late 1940s, unit record equipment such as the IBM 602 and IBM 604, were programmed by control panels<br>
     in a similar way; as were the first electronic computers. However, with the concept of the stored-program computers introduced in 1949, both programs and data<br>
      were stored and manipulated in the same way in computer memory.<br>
      <br>
    Machine code was the language of early programs, written in the instruction set of the particular machine, often in binary notation. Assembly languages were soon<br>
    developed that let the programmer specify instruction in a text format, (e.g., ADD X, TOTAL), with abbreviations for each operation code and meaningful names for<br>
     specifying addresses. However, because an assembly language is little more than a different notation for a machine language, any two machines with different<br>
      instruction sets also have different assembly languages. Kathleen Booth created one of the first Assembly languages in 1950 for various computers at Birkbeck<br>
       College.<br>
       <br>
    <h3 id="mod">Modern programming</h3>
    <hr>
    <h4 id="qa">Quality requirements</h4>
    Whatever the approach to development may be, the final program must satisfy some fundamental properties. The following properties are among the most<br>
    important:<br>
    <br>
    <ul>
  <li> Reliability: how often the results of a program are correct. This depends on conceptual correctness of algorithms, and minimization of programming mistakes,<br>
     such as mistakes in resource management (e.g., buffer overflows and race conditions) and logic errors (such as division by zero or off-by-one errors).</li> 
    <li>  Robustness: how well a program anticipates problems due to errors (not bugs). This includes situations such as incorrect, inappropriate or corrupt data,<br>
     unavailability of needed resources such as memory, operating system services and network connections, user error, and unexpected power outages.</li> 
    <li>  Usability: the ergonomics of a program: the ease with which a person can use the program for its intended purpose or in some cases even unanticipated<br>
     purposes. Such issues can make or break its success even regardless of other issues. This involves a wide range of textual, graphical and sometimes hardware<br>
      elements that improve the clarity, intuitiveness, cohesiveness and completeness of a program's user interface.</li> 
    <li> Portability: the range of computer hardware and operating system platforms on which the source code of a program can be compiled/interpreted and run. This<br>
     depends on differences in the programming facilities provided by the different platforms, including hardware and operating system resources, expected<br>
      behavior of the hardware and operating system, and availability of platform specific compilers (and sometimes libraries) for the language of the source code.</li> 
    <li> Maintainability: the ease with which a program can be modified by its present or future developers in order to make improvements or customizations, fix bugs<br>
     and security holes, or adapt it to new environments. Good practices[24] during initial development make the difference in this regard. This quality may not be<br>
      directly apparent to the end user but it can significantly affect the fate of a program over the long term.</li> 
    <li>  Efficiency/performance: Measure of system resources a program consumes (processor time, memory space, slow devices such as disks, network bandwidth and<br>
     to some extent even user interaction): the less, the better. This also includes careful management of resources, for example cleaning up temporary files and<br>
      eliminating memory leaks.</li> 
    </ul>
<h4 id="Read"> Readability of source code</h4>
    In computer programming, readability refers to the ease with which a human reader can comprehend the purpose, control flow, and operation of source code. It<br>
     affects the aspects of quality above, including portability, usability and most importantly maintainability.<br>
    <br>
    Readability is important because programmers spend the majority of their time reading, trying to understand and modifying existing source code, rather than writing<br>
     new source code. Unreadable code often leads to bugs, inefficiencies, and duplicated code. A study[25] found that a few simple readability transformations made<br>
      code shorter and drastically reduced the time to understand it.<br>
      
    <h4 id="Algo"> Algorithmic complexity</h4>
    The academic field and the engineering practice of computer programming are both largely concerned with discovering and implementing the most efficient<br>
     algorithms for a given class of problem. For this purpose, algorithms are classified into orders using so-called Big O notation, which expresses resource use, such as<br>
      execution time or memory consumption, in terms of the size of an input. Expert programmers are familiar with a variety of well-established algorithms and their<br>
       respective complexities and use this knowledge to choose algorithms that are best suited to the circumstances.<br>
    
    <h5 id="Chess">  Chess algorithms as an example</h5>
    "Programming a Computer for Playing Chess" was a 1950 paper that evaluated a "minimax" algorithm that is part of the history of algorithmic complexity; a course<br>
     on IBM's Deep Blue (chess computer) is part of the computer science curriculum at Stanford University.[27]<br>
    
   <h3 id="Lang"> Programming languages</h3>
   <hr><br>
    Different programming languages support different styles of programming (called programming paradigms). The choice of language used is subject to many<br>
     considerations, such as company policy, suitability to task, availability of third-party packages, or individual preference. Ideally, the programming language best<br>
      suited for the task at hand will be selected. Trade-offs from this ideal involve finding enough programmers who know the language to build a team, the availability of<br>
       compilers for that language, and the efficiency with which programs written in a given language execute. Languages form an approximate spectrum from "low-level"<br>
        to "high-level"; "low-level" languages are typically more machine-oriented and faster to execute, whereas "high-level" languages are more abstract and easier to use<br>
         but execute less quickly. It is usually easier to code in "high-level" languages than in "low-level" ones.<br>
    
        <h3 id="Progers"> Programmers</h3>
        <hr><br>
    Computer programmers are those who write computer software. Their jobs usually involve:<br>
   <ul>
    <li>Coding</li>
<li>Debugging</li>
<li>Documentation</li>
<li>Integration</li>
<li>Maintenance</li>
<li>Requirements analysis</li>
<li>Software architecture</li>
<li>Software testing</li>
<li>Specification</li>
</ul> 
</body>
</html>